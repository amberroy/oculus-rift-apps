<!doctype html>
<html lang="en">
<!--
  Copyright (c) Amber Roy 2014

  Image Credits:
  white-dojo.png - https://brianleetrewitt.wordpress.com/2013/06/07/matrix-dojo/

  Sound effects:
  hard-pop.wav - https://www.freesound.org/people/juskiddink/sounds/108616/
  flapping-thud.wav - https://www.freesound.org/people/Setuniman/sounds/131141/
  koto-hit.wav - https://www.freesound.org/people/Mondschein90/sounds/175672/
  monochord-03.wav - https://www.freesound.org/people/Jagadamba/sounds/253765/
  gong.wav - https://www.freesound.org/people/SuperDaveOsbourne/sounds/63643/
  flute.wav - https://www.freesound.org/people/Soughtaftersounds/sounds/145447/
  low-bing.wav - https://www.freesound.org/people/nickgoa/sounds/186836/
-->
  <head>
    <title>Rift Dojo - Leap Motion 3D Game Jam</title>
    <meta charset="utf-8">
    <style>
      body {
        font-family: Monospace;
        margin: 0px;
        padding: 0;
      }

    </style>

    <!-- Use local libs for faster load times during development. 
      <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
      <script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
    -->
    <script src="js/three.min.js"></script>
    <script src="js/helvetiker_regular.typeface.js"></script>

    <!-- VR scripts from the THREE.js repo, VREffect modified slightly. -->
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>

    <!--
      <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
      <script src="//js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>
    -->
    <script src="js/leap-0.6.3.min.js"></script> 
    <script src="js/leap-plugins-0.1.9.js"></script> 

</head>

<body>
  <canvas id="scene"></canvas>
</body>

<script>

var DEBUG = true;
var frameCount = 0;
var ZERO_VECTOR3 = new THREE.Vector3(0,0,0);

var vrControls, vrEffect;
var scene, camera, renderer;

var SceneParams = Object.freeze({
  skyBoxWidth: 18,
  skyBoxHeight: 8,
  skyBoxDepth: 18,
});

var SceneState = {
  isAnimating: true,
  stopAnimationRequest: false,
}

var GameParams = Object.freeze({
  ballRadius: 0.04,
  ballStartX: 0.0,
  ballStartY: 0.03,
  ballStartZ: -3.0,
  ballRangeX: 0.3,    // 0.3
  ballRangeY: 0.2,    // 0.2
  ballIntervalZ: 1.0,
  ballStopZ: 1.5,
  ballSpeedStart: 0.010,
  ballSpeedInc: 0.1,
  hitTolerance: 0.0,
  grabStrength: 0.5,
  ballColor: 0xcc0000,// red
  ballCount: 25,      // 25
  homeCount: 1,
  playerBufferZ: 0.1,
  playerWidth: 0.5,
  playerHeightUp: 0.2,
  playerHeightDown: 2.0,
  missedEffectMillis: 500,
  playerLives: 3, // 3
  homeStartY: -0.05,
  homeStartZ: -0.4,
  soundHitBall: new Audio("sounds/hard-pop.wav"),
  soundHitPlayer: new Audio("sounds/flapping-thud.wav"),
  soundGameOver: new Audio("sounds/gong.wav"),
  soundGameStart: new Audio("sounds/flute.wav"),
  soundNextLevel: new Audio("sounds/koto-hit.wav"),
  soundRestartLevel: new Audio("sounds/monochord-03.wav"),
  soundLastBall: new Audio("sounds/low-bing.wav"),
});

var TextParams = Object.freeze({
  color: 0x000000,
  startY: 1.1,
  startZ: -1 * SceneParams.skyBoxDepth/2,
  font: "helvetiker",
  height: 0.001,
  levelStartX: -0.40,
  levelSize: 0.20,
  levelTimeout: 2000,
  gameStartX: -0.64,
  gameSize: 0.17,
  gameTimeout: 3000,
});

var GameState = {
  level: 0,
  ballSpeed: 0,
  ballObjects: [],
  handObjects: [],
  leapFrame: null,
  textObject: null,
  hitCount: 0,
  missCount: 0,
  isPlayerHit: false,
  livesLeft: GameParams.playerLives,
  gameOver: false,
  ballGroup: null,
  headPosition: new THREE.Vector3(0,0,0),
};

var BallState = {
  isInPlay: false,
  isInHand: false,
  handId: null,
};


function initScene() {

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    75,     // fov
    window.innerWidth / window.innerHeight,
    0.1,    // near
    10000   // far 
  );

  canvas = document.getElementById('scene');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas,
  });
  renderer.setClearColor(0x808080); // gray

  renderer.setSize(window.innerWidth, window.innerHeight);

  onResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };
  window.addEventListener('resize', onResize, false);


  var light = new THREE.PointLight(0xffffff, 1, 1000);
  scene.add(light);

  createSkyBox();

  GameParams.soundGameStart.play();
  //createLevel(1);
  createHomeScreen();
}

function clearLevel() {
  scene.remove(GameState.ballGroup);
  scene.remove(GameState.text);

  GameState.level = 0;
  GameState.hitCount = 0;  
  GameState.missCount = 0;  
  GameState.isPlayerHit = false;
  GameState.gameOver = false;
  GameState.ballObjects = [];
  GameState.ballGroup = new THREE.Object3D();
}

function createHomeScreen() {

  clearLevel();
  GameState.level = 0;

  var ballGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  //var ballTexture = new THREE.ImageUtils.loadTexture("images/yinyang.png")
  //var ballMat = new THREE.MeshPhongMaterial({map: ballTexture});  
  var ballMat = new THREE.MeshPhongMaterial({color: GameParams.ballColor});  
  var ball = new THREE.Mesh(ballGeo, ballMat);
  ball.position.set(0, GameParams.homeStartY, GameParams.homeStartZ);
  //ball.rotateOnAxis( new THREE.Vector3(0,1,0), ROTATE_ANGLE);

  ball.ballState = Object.create(BallState);
  GameState.ballObjects.push(ball);
  GameState.ballGroup.add(ball);
  scene.add(GameState.ballGroup);

}

function createLevel(level) {

  clearLevel();
  GameState.level = level;

  GameState.ballSpeed = GameState.ballSpeed + (GameParams.ballSpeedStart *
                        (GameParams.ballSpeedInc * (GameState.level-1)));

  for (var i=0; i < GameParams.ballCount; i++) {
    createBallObject(GameParams.ballColor, i);
  }
  scene.add(GameState.ballGroup);

  createTextObject("Level " + GameState.level,
                   TextParams.levelStartX,
                   TextParams.levelSize,
                   TextParams.levelTimeout);
}

function createBallObject(color, index) {

  var ballGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var ballMat = new THREE.MeshPhongMaterial({color: color});  
  var ball = new THREE.Mesh(ballGeo, ballMat);
  randomBallPosition(ball, index);

  ball.ballState = Object.create(BallState);
  ball.ballState.isInPlay = true;
  GameState.ballObjects.push(ball);
  GameState.ballGroup.add(ball);

  return ball;
}

function randomBallPosition(ball, index) {
  var randX = Math.random() * (GameParams.ballRangeX*2) - GameParams.ballRangeX;
  var randY = Math.random() * (GameParams.ballRangeY*2) - GameParams.ballRangeY;

  var ballX = GameParams.ballStartX + randX;
  var ballY = GameParams.ballStartY + randY;
  var ballZ = GameParams.ballStartZ + (GameParams.ballIntervalZ * index * -1);
  ball.position.fromArray([ballX, ballY, ballZ]);

}

function createTextObject(text, startX, size, timeout) {
  var params = { 
    font: TextParams.font,
    size: size,
    height: TextParams.height
  };
  var textGeo = new THREE.TextGeometry(text, params);
  var textMat = new THREE.MeshBasicMaterial({color: TextParams.color });
  var text = new THREE.Mesh(textGeo, textMat);
  text.position.fromArray( [startX, TextParams.startY, TextParams.startZ] );
  scene.add(text);

  setTimeout( function() {
    scene.remove(text); 
  }, timeout);
}

function createSkyBox() {
  
  var imagePrefix = "images/white-dojo-";
  var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
  var imageSuffix = ".png";
  var skyGeometry = new THREE.BoxGeometry(SceneParams.skyBoxWidth,
                                          SceneParams.skyBoxHeight, 
                                          SceneParams.skyBoxDepth);
  
  var materialArray = [];
  for (var i = 0; i < 6; i++)
    materialArray.push( new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
      side: THREE.BackSide
    }));
  var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
  var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
  var skyBoxY = SceneParams.skyBoxHeight/2 - GameParams.playerHeightDown;
  skyBox.position.set(0, skyBoxY, 0);
  scene.add( skyBox );

}

function initVR() {

  vrControls = new THREE.VRControls(camera);
  vrEffect = new THREE.VREffect(renderer);

  var options = {}; // none for now
  Leap.loop(options, onLeapFrame);
  Leap.loopController.use('transform', { vr: true, effectiveParent: camera });
  Leap.loopController.use('boneHand', { scene: scene, arm: true });
  // Plugins handHolding and handEntry already included with leap plugins.
  // Leap tracks hands up to about 50 cm (20 inches) in front of sensor.

}

function onLeapFrame(frame) {
  GameState.leapFrame = frame;
  GameState.handObjects = frame.hands;
}

function onKeyPress(event) {

  switch(event.which) {
    case 'z'.charCodeAt(0):  
      vrControls.zeroSensor();
      break;
    case 'f'.charCodeAt(0):  
      vrEffect.setFullScreen(true);
      break;
    case 13:   // "Enter" key
      vrEffect.setFullScreen(true);
      break;
  }
  if (DEBUG) {
    console.log("keypress", event.which);
    if (event.which === ' '.charCodeAt(0)) {
      // Pause/play animaiton on space bar.
      if (SceneState.isAnimating) {
        SceneState.stopAnimationRequest = true;
        console.log("Animation PAUSED");
      } else {
        console.log("Animation PLAYING");
        SceneState.isAnimating = true;
      }
    }
  }
}
window.addEventListener("keypress", onKeyPress, true);

function updateGameState() {

  checkHandPosition();
  updateBallPosition();

  if (GameState.gameOver) {
    // Game Over, return to the home screen.
    GameParams.soundGameOver.play();
    clearLevel();
    console.log("writing GAME OVER");
    createTextObject("GAME OVER",
                     TextParams.gameStartX,
                     TextParams.gameSize,
                     TextParams.gameTimeout);
    setTimeout( function() {
      SceneState.isAnimating = true;
      GameState.livesLeft = GameParams.playerLives;
      createHomeScreen();
    }, TextParams.gameTimeout);

  } else if (GameState.level === 0 && 
             GameState.hitCount === GameParams.homeCount) {
    // Exit the home screen and load first level.
    GameParams.soundGameStart.play();
    createLevel(1);

  } else if (GameState.hitCount === GameParams.ballCount) {
    // Player hit all balls, advance to next level.
    GameParams.soundNextLevel.play();
    createLevel(GameState.level+1);

  } else if (GameState.hitCount + GameState.missCount === GameParams.ballCount) {
    // End of level but not all balls hit, restart level.
    GameParams.soundRestartLevel.play();
    createLevel(GameState.level);

  } else if (GameState.isPlayerHit) {
    // Player got hit with a ball, restart level.
    GameParams.soundRestartLevel.play();
    createLevel(GameState.level);
  }

}  

function checkHandPosition() {

  for (var i=0; i < GameState.handObjects.length; i++) {
    // Does this hand collide with any balls?
    var hand = GameState.handObjects[i];

    var palmPosition = new THREE.Vector3().fromArray(hand.palmPosition);

    for (var j=0; j < GameState.ballObjects.length; j++) {
      var ball = GameState.ballObjects[j];
      var ballRadius = ball.geometry.boundingSphere.radius;
      // If we're on level zero, allow player to hit stationary ball.
      if (!ball.ballState.isInPlay && GameState.level > 0) {
        continue;
      }

      // Simple collision detection algorithm.
      var distance = palmPosition.distanceTo(ball.position);
      if (distance < ballRadius + GameParams.hitTolerance) {
        if (DEBUG) console.log("Hand["+i+"] HIT Ball["+j+"] ", ball.position);
        // Hit!
        GameState.hitCount++;
        if (GameState.hitCount === GameParams.ballCount) {
          GameParams.soundLastBall.play();
        } else {
          GameParams.soundHitBall.play();
        }
        ball.ballState.isInPlay = false;

        // Leave ball in the scene for now, but make invisible.
        ball.visible = false;
      }
    }
  }  
}

function updateBallPosition() {

  // Update position of all balls in play or in hands.
  for (var i=0; i < GameState.ballObjects.length; i++) {
    var ball = GameState.ballObjects[i];

    if (ball.ballState.isInHand) {
      var hand = GameState.leapFrame.hand(ball.ballState.handId);
      if (!hand.valid) {
        console.log("Hand "+i+" was holding ball, but longer in frame");
        ball.visible = false;
        ball.ballState.isInHand = false;
        ball.handId = null;
      } else {
        if (hand.grabStrength > GameParams.grabStrength) {
          ball.position.fromArray(hand.palmPosition);
        } else {
          if (DEBUG) console.log("Hand["+i+"] DROPPED Ball", ball.position);
          ball.visible = false;
          ball.ballState.isInHand = false;
          ball.handId = null;
        }  
      }
    }

    if (ball.ballState.isInPlay && 
        ball.position.z > camera.position.z - GameParams.playerBufferZ)  {

      // Ball just went into players buffer zone, check for impact.
      if (ball.position.x > camera.position.x - GameParams.playerWidth/2 &&
          ball.position.x < camera.position.x + GameParams.playerWidth/2 &&
          ball.position.y < camera.position.y + GameParams.playerHeightUp &&
          ball.position.y > camera.position.y - GameParams.playerHeightDown) {

        // Impact!  
        impactEffect(ball);
        ball.ballState.isInPlay = false;
        SceneState.stopAnimationRequest = true;
        GameState.livesLeft--;
        GameParams.soundHitPlayer.play();
        setTimeout(function () {
          if (GameState.livesLeft === 0) {
            GameState.gameOver = true;
          } else {
            GameState.isPlayerHit = true;
          }
          SceneState.isAnimating = true;
        }, GameParams.missedEffectMillis);
      } else {
        // Ball passed player, stop it when out of arms reach.
        if (ball.position.z > GameParams.ballStopZ) {
          impactEffect(ball); // Use same effect for now.
          ball.ballState.isInPlay = false;
          GameState.missCount++;
        }
      }
    }

    if (ball.ballState.isInPlay) {
      // Move ball according to initial speed and current level.
      var percentInc = GameParams.ballSpeedInc * (GameState.level-1);
      var ballSpeedAdd = GameParams.ballSpeedStart * percentInc;
      var ballStep = GameParams.ballSpeedStart + ballSpeedAdd;
      ball.translateZ(ballStep);
    }

  }
}

function impactEffect(ball) {

  ball.visible = false;
  var splatGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var color = ball.material.color;
  var splatMat = new THREE.MeshBasicMaterial({color: color, side: THREE.BackSide});
  var splat = new THREE.Mesh(splatGeo, splatMat);
  splat.position.set(ball.position.x, ball.position.y, ball.position.z);
  GameState.ballGroup.add(splat);

}


function update() {
  frameCount++;

  updateGameState();

  var cameraPosition = camera.position.clone();
  var lastHeadPosition = GameState.headPosition;
  vrControls.update();  // Resets camera to absolute head position from HMD.
  GameState.headPosition = camera.position.clone();
  if (GameState.headPosition.equals(cameraPosition)) {
    // On Firefox, if no HMD position data, then camera is not reset. Force to zero.
    GameState.headPosition = ZERO_VECTOR3;
  }
  // Add any head movement (via positional tracking) to the camera position.
  camera.position.set(cameraPosition.x + (GameState.headPosition.x - lastHeadPosition.x),
                      cameraPosition.y + (GameState.headPosition.y - lastHeadPosition.y),
                      cameraPosition.z + (GameState.headPosition.z - lastHeadPosition.z));

}

function logDebugInfo() {
  // Nothing for now.
}

function animate() { 

  requestAnimationFrame(animate);

  if (SceneState.stopAnimationRequest) {
    logDebugInfo();
    SceneState.isAnimating = false;
    SceneState.stopAnimationRequest = false;
  }

  if (SceneState.isAnimating) {
    vrEffect.render(scene, camera); 
    update();
  }

}

function main() {

  initScene()
  initVR();
  //render(); // XXX
  animate();  // XXX
}
window.addEventListener("load", main);


</script>
</html>
