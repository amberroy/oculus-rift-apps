<!doctype html>
<html lang="en">
  <!-- Copyright (c) Amber Roy 2014  -->
  <head>
    <title>Rift Dojo - Leap Motion 3D Game Jam</title>
    <meta charset="utf-8">
    <style>
      body {
        font-family: Monospace;
        margin: 0px;
        padding: 0;
      }

    </style>

    <!-- Use local libs for faster load times during development. 
      <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
      <script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
    -->
    <script src="js/three.min.js"></script>
    <script src="js/helvetiker_regular.typeface.js"></script>

    <!-- VR scripts from the THREE.js repo, VREffect modified slightly. -->
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>

    <!--
      <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
      <script src="//js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>
    -->
    <script src="js/leap-0.6.3.min.js"></script> 
    <script src="js/leap-plugins-0.1.9.js"></script> 

</head>

<body>
  <canvas id="scene"></canvas>
</body>

<script>

var DEBUG = true;
var frameCount = 0;
var stopAnimation = false;
var stopAnimationPending = false;
var ZERO_VECTOR3 = new THREE.Vector3(0,0,0);

var vrControls, vrEffect;
var scene, camera, renderer;

var gameParams = Object.freeze({
  ballRadius: 0.04,
  ballStartX: 0.0,
  ballStartY: 0.03,
  ballStartZ: -2.0,
  ballRangeX: 0.3,
  ballRangeY: 0.2,
  ballIntervalZ: 0.5,
  ballSpeedStart: 0.005,
  ballSpeedInc: 0.1,
  hitTolerance: 0.0,
  grabStrength: 0.5,
  colorToHit: 0xcc0000,
  colorToGrab: 0x0000cc,
  ballCount: 5,
});

var textParams = Object.freeze({
  color: 0xffffff,
  startX: -0.05,
  startY: 0.03,
  startZ: -0.5,
  font: "helvetiker",
  size: 0.05,
  height: 0.001,
});

var gameState = {
  level: 0,
  ballSpeed: 0,
  ballObjects: [],
  handObjects: [],
  leapFrame: null,
  textObject: null,
  doneCount: 0,
  gameOver: false,
  ballGroup: null,
  headPosition: new THREE.Vector3(0,0,0),
};

var ballState = {
  isInPlay: false,
  isInHand: false,
  isFalling: false,
  isGrounded: false,
  wasHit: false,
  wasGrab: false,
  handId: null,
};


function initScene() {

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    75,     // fov
    window.innerWidth / window.innerHeight,
    0.1,    // near
    10000   // far 
  );

  canvas = document.getElementById('scene');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas,
  });
  renderer.setClearColor(0x808080); // gray

  renderer.setSize(window.innerWidth, window.innerHeight);

  onResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };
  window.addEventListener('resize', onResize, false);


  var light = new THREE.PointLight(0xffffff, 1, 1000);
  scene.add(light);

  createLevel(1);
}

function createLevel(level) {
  scene.remove(gameState.ballGroup);
  scene.remove(gameState.text);

  gameState.level = level;
  gameState.doneCount = 0;  
  gameState.gameOver = false;
  gameState.ballObjects = [];
  gameState.ballGroup = new THREE.Object3D();
  gameState.ballSpeed = gameState.ballSpeed + (gameParams.ballSpeedStart *
                        (gameParams.ballSpeedInc * (gameState.level-1)));

  var toGrabIndex = Math.floor(Math.random() * gameParams.ballCount);
  for (var i=0; i < gameParams.ballCount; i++) {
    var ball;
    if (toGrabIndex === i) {
      createBallObject(gameParams.colorToGrab, i);
    } else {
      createBallObject(gameParams.colorToHit, i);
    }
  }
  scene.add(gameState.ballGroup);

  createTextObject("Level "+gameState.level); 
  if (DEBUG) console.log("Started Level "+gameState.level);
}

function createBallObject(color, index) {

  var ballGeo = new THREE.SphereGeometry(gameParams.ballRadius, 16, 16);
  var ballMat = new THREE.MeshPhongMaterial({color: color});
  var ball = new THREE.Mesh(ballGeo, ballMat);
  randomBallPosition(ball, index);
  ball.ballState = Object.create(ballState);
  ball.ballState.isInPlay = true;
  gameState.ballObjects.push(ball);
  gameState.ballGroup.add(ball);
  // colors: 0x00cc00 (lime), 0x0000cc (blue), 0xcc0000 (red), 0xcccc00 (yellow)
  return ball;
}

function randomBallPosition(ball, index) {
  var randX = Math.random() * (gameParams.ballRangeX*2) - gameParams.ballRangeX;
  var randY = Math.random() * (gameParams.ballRangeY*2) - gameParams.ballRangeY;

  var ballX = gameParams.ballStartX + randX;
  var ballY = gameParams.ballStartY + randY;
  var ballZ = gameParams.ballStartZ + (gameParams.ballIntervalZ * index * -1);
  ball.position.fromArray([ballX, ballY, ballZ]);

}

function createTextObject(text) {
  var params = { 
    font: textParams.font,
    size: textParams.size,
    height: textParams.height
  };
  var textGeo = new THREE.TextGeometry(text, params);
  var textMat = new THREE.MeshBasicMaterial({color: textParams.color });
  var text = new THREE.Mesh(textGeo, textMat);
  text.position.fromArray( [textParams.startX, textParams.startY, textParams.startZ] );
  scene.add(text);

  setTimeout( function() {
    scene.remove(text); 
  }, 2000);
}

function initVR() {

  vrControls = new THREE.VRControls(camera);
  vrEffect = new THREE.VREffect(renderer);

  var options = {}; // none for now
  Leap.loop(options, onLeapFrame);
  Leap.loopController.use('transform', { vr: true, effectiveParent: camera });
  Leap.loopController.use('boneHand', { scene: scene, arm: true });
  // Leap tracks hands up to about 50 cm (20 inches) in front of sensor.

}

function onLeapFrame(frame) {
  gameState.leapFrame = frame;
  gameState.handObjects = frame.hands;
}

function onKeyPress(event) {

  switch(event.which) {
    case 'z'.charCodeAt(0):  
      vrControls.zeroSensor();
      break;
    case 'f'.charCodeAt(0):  
      vrEffect.setFullScreen(true);
      break;
    case 13:   // "Enter" key
      vrEffect.setFullScreen(true);
      break;
  }
  if (DEBUG) {
    console.log("keypress", event.which);
    if (event.which === ' '.charCodeAt(0)) {
      // Pause/play animaiton on space bar.
      if (stopAnimation) {
        console.log("Animation PLAYING");
        stopAnimation = false;
      } else {
        stopAnimation = true;
        stopAnimationPending = true;
        console.log("Animation PAUSED");
      }
    }
  }
}
window.addEventListener("keypress", onKeyPress, true);

function updateGameState() {

  checkHandPosition();
  updateBallPosition();

  // Move to next level, or restart the current one.
  if (gameState.doneCount === gameParams.ballCount || gameState.gameOver) {
    createLevel( gameState.gameOver ? gameState.level : gameState.level+1 );
  }

}  

function checkHandPosition() {

  // Do any hands collide with any balls?
  for (var i=0; i < gameState.handObjects.length; i++) {
    var hand = gameState.handObjects[i];
    var palmPosition = new THREE.Vector3().fromArray(hand.palmPosition);

    for (var j=0; j < gameState.ballObjects.length; j++) {
      var ball = gameState.ballObjects[j];
      var ballRadius = ball.geometry.boundingSphere.radius;
      if (!ball.ballState.isInPlay) {
        continue;
      }

      // Simple collision detection algorithm.
      var distance = palmPosition.distanceTo(ball.position);
      if (distance < ballRadius + gameParams.hitTolerance) {
        if (hand.grabStrength > gameParams.grabStrength) {
          // Grab!
          if (DEBUG) console.log("Hand["+i+"] GRABBED Ball["+j+"] ", ball.position);
          gameState.doneCount++;
          ball.ballState.isInHand = true;
          ball.ballState.isInPlay = false;
          ball.ballState.wasGrab = true;
          ball.ballState.handId = hand.id; 
        } else {
          // Hit!
          if (DEBUG) console.log("Hand["+i+"] HIT Ball["+j+"] ", ball.position);
          ball.visible = false;
          gameState.doneCount++;
          ball.ballState.isInPlay = false;
          ball.ballState.isFalling = true;
          ball.ballState.wasHit = true;
        }
      }
    }
  }  
}

function updateBallPosition() {

  // Update position of all balls in play or in hands.
  for (var i=0; i < gameState.ballObjects.length; i++) {
    var ball = gameState.ballObjects[i];

    if (ball.ballState.isInHand) {
      var hand = gameState.leapFrame.hand(ball.ballState.handId);
      if (!hand.valid) {
        console.log("Hand "+i+" was holding ball, but longer in frame");
        ball.ballState.isInHand = false;
        ball.ballState.isFalling = true;
        ball.handId = null;
      } else {
        if (hand.grabStrength > gameParams.grabStrength) {
          ball.position.fromArray(hand.palmPosition);
        } else {
          if (DEBUG) console.log("Hand["+i+"] DROPPED Ball", ball.position);
          ball.visible = false;
          ball.ballState.isInHand = false;
          ball.ballState.isFalling = true;
          hand.data("ball", null);
        }  
      }
    }

    if (ball.ballState.isInPlay && ball.position.z > 0)  {
      // Ball just went out of play.
      if (DEBUG) console.log("Ball["+i+"] went out of play with visible="+ball.visible);
      if (ball.ballState.wasHit) {
        gameState.doneCount++;
      } else {
        gameState.gameOver = true;  
      }
      ball.ballState.isInPlay = false;
    }

    if (ball.ballState.isInPlay) {
      // Move ball according to initial speed and current level.
      var percentInc = gameParams.ballSpeedInc * (gameState.level-1);
      var ballSpeedAdd = gameParams.ballSpeedStart * percentInc;
      ball.translateZ(gameParams.ballSpeedStart + ballSpeedAdd);
    }

  }
}


function render() {
  if (stopAnimation) {
    if (stopAnimationPending) {
      logDebugInfo();
      stopAnimationPending = false;
    }
    requestAnimationFrame(render);
    return;
  }
  frameCount++;

  updateGameState();

  var cameraPosition = camera.position.clone();
  var lastHeadPosition = gameState.headPosition;
  vrControls.update();  // Resets camera to absolute head position from HMD.
  gameState.headPosition = camera.position.clone();
  if (gameState.headPosition.equals(cameraPosition)) {
    // On Firefox, if no HMD position data, then camera is not reset. Force to zero.
    gameState.headPosition = ZERO_VECTOR3;
  }
  // Add any head movement (via positional tracking) to the camera position.
  camera.position.set(cameraPosition.x + (gameState.headPosition.x - lastHeadPosition.x),
                      cameraPosition.y + (gameState.headPosition.y - lastHeadPosition.y),
                      cameraPosition.z + (gameState.headPosition.z - lastHeadPosition.z));
  vrEffect.render(scene, camera);  

  requestAnimationFrame(render);
}

function logDebugInfo() {
  for (var i=0; i < gameState.ballObjects.length; i++) {
    var ball = gameState.ballObjects[i];
    console.log("ball[" + i + "] state: ", ball.ballState);
  }
}

function main() {

  initScene()
  initVR();
  render();
}
window.addEventListener("load", main);


</script>
</html>
