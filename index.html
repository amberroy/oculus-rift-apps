<!doctype html>
<html lang="en">
<!--
  Copyright (c) Amber Roy 2014

  Image Credits:
  white-dojo.png - http://brianleetrewitt.wordpress.com/2013/06/07/matrix-dojo/
  yinyang.png - based on http://cosmicnavigator.com/node/1552

  Sound effects:
  hard-pop.wav - http://www.freesound.org/people/juskiddink/sounds/108616/
  flapping-thud.wav - http://www.freesound.org/people/Setuniman/sounds/131141/
  koto-hit.wav - http://www.freesound.org/people/Mondschein90/sounds/175672/
  monochord-03.wav - http://www.freesound.org/people/Jagadamba/sounds/253765/
  gong.wav - http://www.freesound.org/people/SuperDaveOsbourne/sounds/63643/
  flute.wav - http://www.freesound.org/people/Soughtaftersounds/sounds/145447/
  low-bing.wav - http://www.freesound.org/people/nickgoa/sounds/186836/
-->
  <head>
    <title>Rift Dojo - Leap Motion 3D Game Jam</title>
    <meta charset="utf-8">
    <style>
      body {
        font-family: Monospace;
        margin: 0px;
        padding: 0;
      }

    </style>

    <!-- Use local libs for faster load times during development. 
      <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
      <script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
      <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
      <script src="//js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>
      <script src="//js.leapmotion.com/leap.rigged-hand-0.1.5.min.js"></script>
    -->
    <script src="js/three.min.js"></script>
    <script src="js/helvetiker_regular.typeface.js"></script>
    <script src="js/leap-0.6.3.min.js"></script> 
    <script src="js/leap-plugins-0.1.9.js"></script> 
    <script src="js/leap.rigged-hand-0.1.5.min.js"></script>

    <!-- VR scripts from the THREE.js repo, VREffect modified slightly. -->
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>


</head>

<body>
  <canvas id="scene"></canvas>
</body>

<script>

var DEBUG = true;
var frameCount = 0;
var ZERO_VECTOR3 = new THREE.Vector3(0,0,0);

var vrControls, vrEffect;
var scene, camera, renderer;

var SceneParams = Object.freeze({
  skyBoxWidth: 18,
  skyBoxHeight: 8,
  skyBoxDepth: 18,
  handModel: "riggedHand",
  handColor: 0xC0C0C0,
});

var SceneState = {
  vrEnabled: false,
  isAnimating: true,
  stopAnimationRequest: false,
  lastTime: Date.now(),
  spinDuration: 5000,
}

var GameParams = Object.freeze({
  ballRadius: 0.04,
  ballStartVR: [0.0, 0.03, -3.0],
  ballStartNoVR: [ 0.0, -0.01, -3.0],
  ballRangeVR: [0.3, 0.2],
  ballRangeNoVR: [0.2, 0.15],
  ballIntervalZ: 1.0,
  ballStopZ: 1.5,
  ballSpeedStart: 0.010,
  ballSpeedInc: 0.2,
  hitTolerance: 0.01,
  grabStrength: 0.5,
  ballColor: 0xcc0000,  // red
  ballCount: 25,        // 25
  homeCount: 1,
  playerBufferZ: 0.1,
  playerWidth: 0.5,
  playerHeightUp: 0.2,
  playerHeightDown: 2.0,
  missedEffectMillis: 500,
  playerLives: 3,       // 3
  homeStartY: -0.05,
  homeStartZ: -0.4,
  soundHitBall: new Audio("sounds/hard-pop.wav"),
  soundHitPlayer: new Audio("sounds/flapping-thud.wav"),
  soundGameOver: new Audio("sounds/gong.wav"),
  soundGameStart: new Audio("sounds/flute.wav"),
  soundNextLevel: new Audio("sounds/koto-hit.wav"),
  soundRestartLevel: new Audio("sounds/monochord-03.wav"),
  soundLastBall: new Audio("sounds/low-bing.wav"),
});

var TextParams = Object.freeze({
  color: 0x000000,
  startY: 1.1,
  startZ: -1 * SceneParams.skyBoxDepth/2,
  font: "helvetiker",
  height: 0.001,
  levelStartX: -0.40,
  levelSize: 0.20,
  levelTimeout: 2000,
  gameStartX: -0.64,
  gameSize: 0.17,
  dojoStartX: -0.50,
  dojoSize: 0.2,
  gameTimeout: 3000,
});

var GameState = {
  level: 0,
  ballSpeed: 0,
  ballObjects: [],
  handObjects: [],
  leapFrame: null,
  textObject: null,
  hitCount: 0,
  missCount: 0,
  isPlayerHit: false,
  livesLeft: GameParams.playerLives,
  gameOver: false,
  ballGroup: null,
  headPosition: new THREE.Vector3(0,0,0),
};

var BallState = {
  isInPlay: false,
  isInHand: false,
  handId: null,
};


function initScene() {

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    75,     // fov
    window.innerWidth / window.innerHeight,
    0.1,    // near
    10000   // far 
  );

  canvas = document.getElementById('scene');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas,
  });
  renderer.setClearColor(0x808080); // gray

  renderer.setSize(window.innerWidth, window.innerHeight);

  onResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };
  window.addEventListener('resize', onResize, false);

  // Virtual Reality rendering and input.
  // VREffect falls back to non-VR mode if browser not VR-enabled.
  // VRControls handles HMD orientation and positional tracking.
  vrControls = new THREE.VRControls(camera);
  vrEffect = new THREE.VREffect(renderer);

  var light = new THREE.PointLight(0xffffff, 1, 1000);
  scene.add(light);

  createSkyBox();

  GameParams.soundGameStart.play();
  createHomeScreen();
}

function clearLevel() {
  scene.remove(GameState.ballGroup);
  scene.remove(GameState.text);

  GameState.level = 0;
  GameState.hitCount = 0;  
  GameState.missCount = 0;  
  GameState.isPlayerHit = false;
  GameState.gameOver = false;
  GameState.ballObjects = [];
  GameState.ballGroup = new THREE.Object3D();
}

function createHomeScreen() {

  clearLevel();
  GameState.level = 0;

  var ballGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var ballTexture = new THREE.ImageUtils.loadTexture("images/yinyang.png")
  var ballMat = new THREE.MeshPhongMaterial({map: ballTexture});  
  var ball = new THREE.Mesh(ballGeo, ballMat);
  ball.position.set(0, GameParams.homeStartY, GameParams.homeStartZ);

  // Rotate ball so the yin-yang symbol starts near the front.
  ball.rotateOnAxis( new THREE.Vector3(0,1,0), 90 * (Math.PI / 180));

  ball.ballState = Object.create(BallState);
  GameState.ballObjects.push(ball);
  GameState.ballGroup.add(ball);
  scene.add(GameState.ballGroup);

  var text = createTextObject("Rift Dojo",
                              TextParams.dojoStartX,
                              TextParams.dojoSize, null);

  // Add to ballGroup so it will be removed when the scene is cleared.
  GameState.ballGroup.add(text);
}

function createLevel(level) {

  clearLevel();
  GameState.level = level;

  GameState.ballSpeed = GameState.ballSpeed + (GameParams.ballSpeedStart *
                        (GameParams.ballSpeedInc * (GameState.level-1)));
 
  createTextObject("Level " + GameState.level,
                   TextParams.levelStartX,
                   TextParams.levelSize,
                   TextParams.levelTimeout);

  setTimeout( function() {
    // Wait a bit before adding objects to the scene.
    for (var i=0; i < GameParams.ballCount; i++) {
      createBallObject(GameParams.ballColor, i);
    }
    scene.add(GameState.ballGroup);

  }, TextParams.levelTimeout);

}

function createBallObject(color, index) {

  var ballGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var ballMat = new THREE.MeshPhongMaterial({color: color});  
  var ball = new THREE.Mesh(ballGeo, ballMat);
  randomBallPosition(ball, index);

  ball.ballState = Object.create(BallState);
  ball.ballState.isInPlay = true;
  GameState.ballObjects.push(ball);
  GameState.ballGroup.add(ball);

  return ball;
}

function randomBallPosition(ball, index) {
  var ballRange = SceneState.vrEnabled ?
                  GameParams.ballRangeVR : GameParams.ballRangeNoVR;
  var randX = Math.random() * (ballRange[0]*2) - ballRange[0];
  var randY = Math.random() * (ballRange[1]*2) - ballRange[1];

  var ballStart = SceneState.vrEnabled ? 
                  GameParams.ballStartVR : GameParams.ballStartNoVR;
  var ballX = ballStart[0] + randX;
  var ballY = ballStart[1] + randY;
  var ballZ = ballStart[2] + (GameParams.ballIntervalZ * index * -1);
  ball.position.fromArray([ballX, ballY, ballZ]);

}

function createTextObject(text, startX, size, timeout) {
  var params = { 
    font: TextParams.font,
    size: size,
    height: TextParams.height
  };
  var textGeo = new THREE.TextGeometry(text, params);
  var textMat = new THREE.MeshBasicMaterial({color: TextParams.color });
  var text = new THREE.Mesh(textGeo, textMat);
  text.position.fromArray( [startX, TextParams.startY, TextParams.startZ] );

  if (timeout) {
    // Remove the text after timeout milliseconds.
    scene.add(text);
    setTimeout( function() {
      scene.remove(text); 
    }, timeout);
  }

  // If no timeout, up to the caller to insert/remove in scene.
  return text;
}

function createSkyBox() {
  
  var imagePrefix = "images/white-dojo-";
  var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
  var imageSuffix = ".png";
  var skyGeometry = new THREE.BoxGeometry(SceneParams.skyBoxWidth,
                                          SceneParams.skyBoxHeight, 
                                          SceneParams.skyBoxDepth);
  
  var materialArray = [];
  for (var i = 0; i < 6; i++)
    materialArray.push( new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
      side: THREE.BackSide
    }));
  var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
  var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
  var skyBoxY = SceneParams.skyBoxHeight/2 - GameParams.playerHeightDown;
  skyBox.position.set(0, skyBoxY, 0);
  scene.add( skyBox );

}

function initLeap() {
  // Setup the Leap Motion Controller.

  var options = {}; // none for now
  Leap.loop(options, onLeapFrame);

  // These two already included in plugs lib but be explicit.
  Leap.loopController.use('handHold');  // for hand.data
  Leap.loopController.use('handEntry');  // for onHandEntry, onHandLost

  // Scale to meters, if VR browser then assume HMD mounted leap.
  Leap.loopController.use('transform', {
    vr: SceneState.vrEnabled,
    scale: SceneState.vrEnabled ? 0.001 : 0.001,
    effectiveParent: camera,
    position: SceneState.vrEnabled ? 
              new THREE.Vector3(0, 0, -0.08) :        // VR default
              new THREE.Vector3(0, -0.25, -0.25),     // for desktop
  });

  switch (SceneParams.handModel) {

  case 'boneHand':
    Leap.loopController.use('boneHand', { scene: scene, arm: true });
    break;

  case 'riggedHand':
    // rigged-hand depends on hand-hold and hand-entry plugins

    Leap.loopController.use('riggedHand', { 

      parent: scene,
      renderer: renderer,
      camera: camera,

      // Plugin controls render loop, calls requestAnimationFrame then renderFn.
      renderFn: render, 

      // Default y = -10in (0.25m) but when mounted on HMD we want it at zero.
      offset: new THREE.Vector3(0, 0, 0),

      // Any valid Three.js material options are valid here.
      materialOptions: {
        color: SceneParams.handColor,
      },

      // Add warning msg to page if no WebGL, uses threejs Detector.js
      checkWebGL: true,

      // Use default settings for scale, positionScale, geometryOptions
      // Note: Leap tracks hands up to about 50 cm (20 inches) in front of sensor.
    });
    break;

  default:
    console.log("Unrecognized handModel", SceneParams.handModel);
  }

}

function onLeapFrame(frame) {
  GameState.leapFrame = frame;
  GameState.handObjects = frame.hands;
}

function onKeyPress(event) {

  switch(event.which) {
    case 'z'.charCodeAt(0):  
      vrControls.zeroSensor();
      break;
    case 'f'.charCodeAt(0):  
      vrEffect.setFullScreen(true);
      break;
    case 13:   // "Enter" key
      vrEffect.setFullScreen(true);
      break;
  }
  if (DEBUG) {
    if (event.which === ' '.charCodeAt(0)) {
      // Pause/play animaiton on space bar.
      if (SceneState.isAnimating) {
        SceneState.stopAnimationRequest = true;
        console.log("Animation PAUSED");
      } else {
        console.log("Animation PLAYING");
        SceneState.isAnimating = true;
      }
    }
  }
}
window.addEventListener("keypress", onKeyPress, true);

function updateGameState() {

  if (GameState.level == 0) {
    updateHomeScreen();
  }

  checkHandPosition();
  updateBallPosition();

  if (GameState.gameOver) {
    // Game Over, return to the home screen.
    GameParams.soundGameOver.play();
    clearLevel();
    createTextObject("GAME OVER",
                     TextParams.gameStartX,
                     TextParams.gameSize,
                     TextParams.gameTimeout);
    setTimeout( function() {
      GameState.livesLeft = GameParams.playerLives;
      createHomeScreen();
    }, TextParams.gameTimeout);

  } else if (GameState.level === 0 && 
             GameState.hitCount === GameParams.homeCount) {
    // Exit the home screen and load first level.
    GameParams.soundGameStart.play();
    createLevel(1);

  } else if (GameState.hitCount === GameParams.ballCount) {
    // Player hit all balls, advance to next level.
    GameParams.soundNextLevel.play();
    createLevel(GameState.level+1);

  } else if (GameState.hitCount + GameState.missCount === GameParams.ballCount) {
    // End of level but not all balls hit, restart level.
    GameParams.soundRestartLevel.play();
    createLevel(GameState.level);

  } else if (GameState.isPlayerHit) {
    // Player got hit with a ball, restart level.
    GameParams.soundRestartLevel.play();
    createLevel(GameState.level);
  }

}  

function checkHandPosition() {

  for (var i=0; i < GameState.handObjects.length; i++) {
    // Does this hand collide with any balls?
    var hand = GameState.handObjects[i];

    var palmPosition = new THREE.Vector3().fromArray(hand.palmPosition);

    for (var j=0; j < GameState.ballObjects.length; j++) {
      var ball = GameState.ballObjects[j];
      var ballRadius = ball.geometry.boundingSphere.radius;
      // If we're on level zero, allow player to hit stationary ball.
      if (!ball.ballState.isInPlay && GameState.level > 0) {
        continue;
      }

      // Simple collision detection algorithm.
      var distance = palmPosition.distanceTo(ball.position);

      if (distance < ballRadius + GameParams.hitTolerance) {

        // Hit!
        GameState.hitCount++;
        if (GameState.hitCount === GameParams.ballCount) {
          GameParams.soundLastBall.play();
        } else {
          GameParams.soundHitBall.play();
        }
        ball.ballState.isInPlay = false;

        // Leave ball in the scene for now, but make invisible.
        ball.visible = false;
      }
    }
  }  
}

function updateBallPosition() {

  // Update position of all balls in play or in hands.
  for (var i=0; i < GameState.ballObjects.length; i++) {
    var ball = GameState.ballObjects[i];

    if (ball.ballState.isInHand) {
      var hand = GameState.leapFrame.hand(ball.ballState.handId);
      if (!hand.valid) {
        ball.visible = false;
        ball.ballState.isInHand = false;
        ball.handId = null;
      } else {
        if (hand.grabStrength > GameParams.grabStrength) {
          ball.position.fromArray(hand.palmPosition);
        } else {
          ball.visible = false;
          ball.ballState.isInHand = false;
          ball.handId = null;
        }  
      }
    }

    if (ball.ballState.isInPlay && 
        ball.position.z > camera.position.z - GameParams.playerBufferZ)  {

      // Ball just went into players buffer zone, check for impact.
      if (ball.position.x > camera.position.x - GameParams.playerWidth/2 &&
          ball.position.x < camera.position.x + GameParams.playerWidth/2 &&
          ball.position.y < camera.position.y + GameParams.playerHeightUp &&
          ball.position.y > camera.position.y - GameParams.playerHeightDown) {

        // Impact!  
        impactEffect(ball);
        ball.ballState.isInPlay = false;
        SceneState.stopAnimationRequest = true;
        GameState.livesLeft--;
        GameParams.soundHitPlayer.play();
        setTimeout(function () {
          if (GameState.livesLeft === 0) {
            GameState.gameOver = true;
          } else {
            GameState.isPlayerHit = true;
          }
          SceneState.isAnimating = true;
        }, GameParams.missedEffectMillis);
      } else {
        // Ball passed player, stop it when out of arms reach.
        if (ball.position.z > GameParams.ballStopZ) {
          impactEffect(ball); // Use same effect for now.
          ball.ballState.isInPlay = false;
          GameState.missCount++;
        }
      }
    }

    if (ball.ballState.isInPlay) {
      // Move ball according to initial speed and current level.
      var percentInc = GameParams.ballSpeedInc * (GameState.level-1);
      var ballSpeedAdd = GameParams.ballSpeedStart * percentInc;
      var ballStep = GameParams.ballSpeedStart + ballSpeedAdd;
      ball.translateZ(ballStep);
    }

  }
}

function impactEffect(ball) {

  ball.visible = false;
  var splatGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var color = ball.material.color;
  var splatMat = new THREE.MeshBasicMaterial({color: color, side: THREE.BackSide});
  var splat = new THREE.Mesh(splatGeo, splatMat);
  splat.position.set(ball.position.x, ball.position.y, ball.position.z);
  GameState.ballGroup.add(splat);

}


function update() {
  frameCount++;

  updateGameState();

  var cameraPosition = camera.position.clone();
  var lastHeadPosition = GameState.headPosition;
  vrControls.update();  // Resets camera to absolute head position from HMD.
  GameState.headPosition = camera.position.clone();
  if (GameState.headPosition.equals(cameraPosition)) {
    // On Firefox, if no HMD position data, then camera is not reset. Force to zero.
    GameState.headPosition = ZERO_VECTOR3;
  }
  // Add any head movement (via positional tracking) to the camera position.
  camera.position.set(cameraPosition.x + (GameState.headPosition.x - lastHeadPosition.x),
                      cameraPosition.y + (GameState.headPosition.y - lastHeadPosition.y),
                      cameraPosition.z + (GameState.headPosition.z - lastHeadPosition.z));

}

function updateHomeScreen() {

  var now = Date.now();
  var timeDiff = now - SceneState.lastTime;
  SceneState.lastTime = now;

  // One full spin every spinDuration milliseconds, angle in radians.
  var fractionOfCircle = timeDiff / SceneState.spinDuration;
  var angle = Math.PI * 2 * fractionOfCircle;

  for (var i=0; i < GameState.ballObjects.length; i++) {
    var ball = GameState.ballObjects[i];
    ball.rotation.y += angle;
  }
}

function logDebugInfo() {
  // Nothing for now.
}

function animate() { 

  if (!SceneParams.handModel === 'riggedHand') {
    // If using rigged hand, plugin runs render loop for us.

    requestAnimationFrame(animate);
    render();
  }
}

function render() {

  if (SceneState.stopAnimationRequest) {
    logDebugInfo();
    SceneState.isAnimating = false;
    SceneState.stopAnimationRequest = false;
  }

  if (SceneState.isAnimating) {
    vrEffect.render(scene, camera); 
    update();
  }

}

function main() {

  if (navigator.getVRDevices) {
    SceneState.vrEnabled = true;
    console.log("VR-enabled browser detected");
  } else {
    SceneState.vrEnabled = false;
    console.log("Browser is not VR-enabled");
  }

  initScene()
  initLeap();
  animate(); 

}
window.addEventListener("load", main);


</script>
</html>
