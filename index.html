<!doctype html>
<html lang="en">
  <!-- Copyright (c) Amber Roy 2014  -->
  <head>
    <title>Rift Dojo - Leap Motion 3D Game Jam</title>
    <meta charset="utf-8">
    <style>
      body {
        font-family: Monospace;
        margin: 0px;
        padding: 0;
      }

    </style>

    <!-- Use local libs for faster load times during development. 
      <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
      <script src="http://mrdoob.github.com/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
    -->
    <script src="js/three.min.js"></script>
    <script src="js/helvetiker_regular.typeface.js"></script>

    <!-- VR scripts from the THREE.js repo, VREffect modified slightly. -->
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>

    <!--
      <script src="//js.leapmotion.com/leap-0.6.3.min.js"></script>
      <script src="//js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>
    -->
    <script src="js/leap-0.6.3.min.js"></script> 
    <script src="js/leap-plugins-0.1.9.js"></script> 

</head>

<body>
  <canvas id="scene"></canvas>
</body>

<script>

var DEBUG = true;
var frameCount = 0;
var stopAnimation = false;
var stopAnimationPending = false;
var ZERO_VECTOR3 = new THREE.Vector3(0,0,0);

var vrControls, vrEffect;
var scene, camera, renderer;

var GameParams = Object.freeze({
  ballRadius: 0.04,
  ballStartX: 0.0,
  ballStartY: 0.03,
  ballStartZ: -2.0,
  ballRangeX: 0.3,    // 0.3
  ballRangeY: 0.2,    // 0.2
  ballIntervalZ: 0.5, // 0.5
  ballSpeedStart: 0.005,
  ballSpeedInc: 0.1,
  hitTolerance: 0.0,
  grabStrength: 0.5,
  colorToPalm: 0xcc0000,  // red
  colorToPunch: 0x0000cc, // blue
  ballCount: 5,
});

var TextParams = Object.freeze({
  color: 0xffffff,
  startX: -0.05,
  startY: 0.03,
  startZ: -0.5,
  font: "helvetiker",
  size: 0.05,
  height: 0.001,
});

var GameState = {
  level: 0,
  ballSpeed: 0,
  ballObjects: [],
  handObjects: [],
  leapFrame: null,
  textObject: null,
  hitCount: 0,
  gameOver: false,
  ballGroup: null,
  headPosition: new THREE.Vector3(0,0,0),
};

var BallState = {
  isPunchBall: false,
  isInPlay: false,
  isInHand: false,
  handId: null,
  outline: null,
};


function initScene() {

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    75,     // fov
    window.innerWidth / window.innerHeight,
    0.1,    // near
    10000   // far 
  );

  canvas = document.getElementById('scene');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas,
  });
  renderer.setClearColor(0x808080); // gray

  renderer.setSize(window.innerWidth, window.innerHeight);

  onResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };
  window.addEventListener('resize', onResize, false);


  var light = new THREE.PointLight(0xffffff, 1, 1000);
  scene.add(light);

  createLevel(1);
}

function createLevel(level) {
  scene.remove(GameState.ballGroup);
  scene.remove(GameState.text);

  GameState.level = level;
  GameState.hitCount = 0;  
  GameState.gameOver = false;
  GameState.ballObjects = [];
  GameState.ballGroup = new THREE.Object3D();
  GameState.ballSpeed = GameState.ballSpeed + (GameParams.ballSpeedStart *
                        (GameParams.ballSpeedInc * (GameState.level-1)));

  var punchBallIndex = Math.floor(Math.random() * GameParams.ballCount);
  for (var i=0; i < GameParams.ballCount; i++) {
    var ball;
    if (punchBallIndex == i) {
      createBallObject(GameParams.colorToPunch, i, true);
    } else {
      createBallObject(GameParams.colorToPalm, i, false);
    }
  }
  scene.add(GameState.ballGroup);

  createTextObject("Level "+GameState.level); 
  if (DEBUG) console.log("Started Level "+GameState.level);
}

function createBallObject(color, index, isPunchBall) {

  var ballGeo = new THREE.SphereGeometry(GameParams.ballRadius, 16, 16);
  var ballMat = new THREE.MeshPhongMaterial({color: color});
  var ball = new THREE.Mesh(ballGeo, ballMat);
  randomBallPosition(ball, index);

  ball.ballState = Object.create(BallState);
  ball.ballState.isInPlay = true;
  ball.ballState.isPunchBall = isPunchBall;
  GameState.ballObjects.push(ball);
  GameState.ballGroup.add(ball);

  if (isPunchBall) {
    var outlineMat = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.BackSide } );
    var outlineMesh = new THREE.Mesh(ballGeo, outlineMat);
    outlineMesh.position = ball.position;
    outlineMesh.scale.multiplyScalar(1.05);
    GameState.ballGroup.add(outlineMesh);
    ball.ballState.outline = outlineMesh;
  }

  return ball;
}

function randomBallPosition(ball, index) {
  var randX = Math.random() * (GameParams.ballRangeX*2) - GameParams.ballRangeX;
  var randY = Math.random() * (GameParams.ballRangeY*2) - GameParams.ballRangeY;

  var ballX = GameParams.ballStartX + randX;
  var ballY = GameParams.ballStartY + randY;
  var ballZ = GameParams.ballStartZ + (GameParams.ballIntervalZ * index * -1);
  ball.position.fromArray([ballX, ballY, ballZ]);

}

function createTextObject(text) {
  var params = { 
    font: TextParams.font,
    size: TextParams.size,
    height: TextParams.height
  };
  var textGeo = new THREE.TextGeometry(text, params);
  var textMat = new THREE.MeshBasicMaterial({color: TextParams.color });
  var text = new THREE.Mesh(textGeo, textMat);
  text.position.fromArray( [TextParams.startX, TextParams.startY, TextParams.startZ] );
  scene.add(text);

  setTimeout( function() {
    scene.remove(text); 
  }, 2000);
}

function initVR() {

  vrControls = new THREE.VRControls(camera);
  vrEffect = new THREE.VREffect(renderer);

  var options = {}; // none for now
  Leap.loop(options, onLeapFrame);
  Leap.loopController.use('transform', { vr: true, effectiveParent: camera });
  Leap.loopController.use('boneHand', { scene: scene, arm: true });
  // Plugins handHolding and handEntry already included with leap plugins.
  // Leap tracks hands up to about 50 cm (20 inches) in front of sensor.

}

function onLeapFrame(frame) {
  GameState.leapFrame = frame;
  GameState.handObjects = frame.hands;
}

function onKeyPress(event) {

  switch(event.which) {
    case 'z'.charCodeAt(0):  
      vrControls.zeroSensor();
      break;
    case 'f'.charCodeAt(0):  
      vrEffect.setFullScreen(true);
      break;
    case 13:   // "Enter" key
      vrEffect.setFullScreen(true);
      break;
  }
  if (DEBUG) {
    console.log("keypress", event.which);
    if (event.which === ' '.charCodeAt(0)) {
      // Pause/play animaiton on space bar.
      if (stopAnimation) {
        console.log("Animation PLAYING");
        stopAnimation = false;
      } else {
        stopAnimation = true;
        stopAnimationPending = true;
        console.log("Animation PAUSED");
      }
    }
  }
}
window.addEventListener("keypress", onKeyPress, true);

function updateGameState() {

  checkHandPosition();
  updateBallPosition();

  // Move to next level, or restart the current one.
  if (GameState.hitCount === GameParams.ballCount || GameState.gameOver) {
    createLevel( GameState.gameOver ? GameState.level : GameState.level+1 );
  }

}  

function checkHandPosition() {

  for (var i=0; i < GameState.handObjects.length; i++) {
    // Does this hand collide with any balls?
    var hand = GameState.handObjects[i];

    var palmPosition = new THREE.Vector3().fromArray(hand.palmPosition);

    for (var j=0; j < GameState.ballObjects.length; j++) {
      var ball = GameState.ballObjects[j];
      var ballRadius = ball.geometry.boundingSphere.radius;
      if (!ball.ballState.isInPlay) {
        continue;
      }

      // Simple collision detection algorithm.
      var distance = palmPosition.distanceTo(ball.position);
      if (distance < ballRadius + GameParams.hitTolerance) {
        // Hit! determine if Punch or Palm.  We don't use this info right now.
        if (hand.grabStrength > GameParams.grabStrength) {
          // Punch!
          if (DEBUG) console.log("Hand["+i+"] PUNCHED Ball["+j+"] ", ball.position);
          // Ignore hit, player was supposed to palm.
          if (!ball.isPunchBall) {
            continue;
          }
        } else {
          // Palm!
          if (DEBUG) console.log("Hand["+i+"] PALMED Ball["+j+"] ", ball.position);
          // Ignore hit, player was supposed to punch.
          if (ball.isPunchBall) {
            continue;
          }
        }
        GameState.hitCount++;
        ball.ballState.isInPlay = false;
        // Leave ball in the scene for now, but make invisible.
        ball.visible = false;
        if (ball.ballState.outline) {
          ball.ballState.outline.visible = false;
        }
      }
    }
  }  
}

function updateBallPosition() {

  // Update position of all balls in play or in hands.
  for (var i=0; i < GameState.ballObjects.length; i++) {
    var ball = GameState.ballObjects[i];

    if (ball.ballState.isInHand) {
      var hand = GameState.leapFrame.hand(ball.ballState.handId);
      if (!hand.valid) {
        console.log("Hand "+i+" was holding ball, but longer in frame");
        ball.visible = false;
        ball.ballState.isInHand = false;
        ball.handId = null;
      } else {
        if (hand.grabStrength > GameParams.grabStrength) {
          ball.position.fromArray(hand.palmPosition);
        } else {
          if (DEBUG) console.log("Hand["+i+"] DROPPED Ball", ball.position);
          ball.visible = false;
          ball.ballState.isInHand = false;
          ball.handId = null;
        }  
      }
    }

    if (ball.ballState.isInPlay && ball.position.z > 0)  {
      // Ball just went out of play.
      GameState.gameOver = true;  
      ball.ballState.isInPlay = false;
    }

    if (ball.ballState.isInPlay) {
      // Move ball according to initial speed and current level.
      var percentInc = GameParams.ballSpeedInc * (GameState.level-1);
      var ballSpeedAdd = GameParams.ballSpeedStart * percentInc;
      var ballStep = GameParams.ballSpeedStart + ballSpeedAdd;
      ball.translateZ(ballStep);
      if (ball.ballState.outline) {
        ball.ballState.outline.position.set(ball.position.x, ball.position.y, ball.position.z);
      }
    }

  }
}


function render() {
  if (stopAnimation) {
    if (stopAnimationPending) {
      logDebugInfo();
      stopAnimationPending = false;
    }
    requestAnimationFrame(render);
    return;
  }
  frameCount++;

  updateGameState();

  var cameraPosition = camera.position.clone();
  var lastHeadPosition = GameState.headPosition;
  vrControls.update();  // Resets camera to absolute head position from HMD.
  GameState.headPosition = camera.position.clone();
  if (GameState.headPosition.equals(cameraPosition)) {
    // On Firefox, if no HMD position data, then camera is not reset. Force to zero.
    GameState.headPosition = ZERO_VECTOR3;
  }
  // Add any head movement (via positional tracking) to the camera position.
  camera.position.set(cameraPosition.x + (GameState.headPosition.x - lastHeadPosition.x),
                      cameraPosition.y + (GameState.headPosition.y - lastHeadPosition.y),
                      cameraPosition.z + (GameState.headPosition.z - lastHeadPosition.z));
  vrEffect.render(scene, camera);  

  requestAnimationFrame(render);
}

function logDebugInfo() {
  for (var i=0; i < GameState.ballObjects.length; i++) {
    var ball = GameState.ballObjects[i];
    console.log("ball[" + i + "] state: ", ball.ballState);
  }
}

function main() {

  initScene()
  initVR();
  render();
}
window.addEventListener("load", main);


</script>
</html>
